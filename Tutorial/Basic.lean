import Mathlib.Data.Matrix.Basic
import Mathlib.Data.Matrix.Reflection
import Mathlib.LinearAlgebra.Matrix.Trace
import Mathlib.Algebra.BigOperators.Basic
import Mathlib.Analysis.SpecialFunctions.Log.Basic
-- import Mathlib.Data.Fin.Tuple.Reflection
-- import Mathlib.Analysis.Calculus.FDeriv.Basic
import Mathlib.Order.Filter.Basic
import Mathlib.Topology.Basic
-- import Mathlib.Topology.Instances.Matrix
-- import Mathlib.LinearAlgebra.Matrix.NonsingularInverse
-- import Mathlib.Data.Nat.Factorization.Basic
-- import Mathlib.LinearAlgebra.Matrix.PosDef
-- import Mathlib.LinearAlgebra.Matrix.Adjugate
-- import Mathlib.LinearAlgebra.FiniteDimensional
import Mathlib.LinearAlgebra.Matrix.Block
import Mathlib.Analysis.InnerProductSpace.Basic
import Mathlib.Analysis.SpecialFunctions.Log.Deriv
open BigOperators
open Finset
open Matrix Filter Set Topology

def mat : Matrix (Fin 2) (Fin 2) РёЮ :=
  !![1, 2;
     3, 4]

#eval dotProductрхБ ![1, 2] ![3, 4]

#check Matrix
#check Matrix (Fin 2) (Fin 2) РёЮ

variable {a b : Matrix (Fin 2) (Fin 2) РёЮ}

variable [Fintype m] [Fintype n] [Fintype p]

#check a 0 1
#check a * b

#check mulрхБ_eq

#check a 1 2
#check (Fin 2)


variable {c d : Matrix (Fin 2) (Fin 5) РёЮ}

#check trace a
#check Matrix.transpose c
#check ((Matrix.transpose c) * d)
#check Matrix.diag
def try1 {i j : Nat}: aрхђ i j = a j i := by
  simp [transpose]
variable {v v1 v2 : (Fin 2 Рєњ РёЮ)}

#check mulVec a v         -- matrix * vector
#check vecMul v a         -- vector * matrix
#check dotProduct v1 v2   -- vector * vector
--!!! definition

-- innerProductofMatrix a b -- is defined as -- РѕЉ i j, (a i j) * (b i j)
def innerProductofMatrix {n m : Nat} (a b : Matrix (Fin n) (Fin m) РёЮ) : РёЮ :=
  РѕЉ i : Fin n, РѕЉ j : Fin m, (a i j) * (b i j)

-- traceMHDotM a b -- is defined as -- trace (aр┤┤ * b)
def traceMHDotM (n m : Nat) (a b: Matrix (Fin n) (Fin m) РёЮ) : РёЮ :=
  trace (aр┤┤ * b)

-- РЪеa, bРЪЕ = trace (aр┤┤ * b)
theorem iProd_eq_traceDot (n m : Nat) (a b : Matrix (Fin n) (Fin m) РёЮ) :
  innerProductofMatrix a b = traceMHDotM n m a b := by
    rw [innerProductofMatrix, traceMHDotM]
    rw [Рєљ mulрхБ_eq, mulрхБ]
    rw [trace]
    simp [dotProduct]
    exact Finset.sum_comm

namespace GateauxDeriv

-- define f' is f's G derivative.
-- Noticing that Grandinet in Mathlib require the space is normed
-- but when we talk about Gateaux derivative of matrix, it seems we don't need to specify a norm of matrix
-- so we may redefine the definition of Gateaux derivative
def HasGateauxDerivAt {m n: Nat} (f : Matrix (Fin m) (Fin n) РёЮ Рєњ РёЮ) (X : Matrix (Fin m) (Fin n) РёЮ) (f' : Matrix (Fin m) (Fin n) РёЮ) : Prop :=
  Рѕђ V : Matrix (Fin m) (Fin n) РёЮ,
    Filter.Tendsto (fun t : РёЮ Рєд (f (X + t Рђб V) - f X ) / t)
      (­ЮЊЮ[РЅа] 0) (­ЮЊЮ (innerProductofMatrix f' V))

-- define f is G differentiable
def GateauxDifferentiable {m n: Nat} (f : Matrix (Fin m) (Fin n) РёЮ Рєњ РёЮ) (X : Matrix (Fin m) (Fin n) РёЮ) : Prop :=
  РѕЃ G : Matrix (Fin m) (Fin n) РёЮ, HasGateauxDerivAt f X G

-- take the derivative of the function which is differentiable
noncomputable
irreducible_def GateauxDeriv {m n: Nat} (f : Matrix (Fin m) (Fin n) РёЮ Рєњ РёЮ) (X : Matrix (Fin m) (Fin n) РёЮ)
    (h : РѕЃ f', HasGateauxDerivAt f X f') : Matrix (Fin m) (Fin n) РёЮ :=
  Classical.choose h

lemma GateauxDeriv_spec {m n: Nat} (f : Matrix (Fin m) (Fin n) РёЮ Рєњ РёЮ) (X : Matrix (Fin m) (Fin n) РёЮ)
    (h : РѕЃ f', HasGateauxDerivAt f X f') : HasGateauxDerivAt f X (GateauxDeriv f X h) := by
  rw [GateauxDeriv_def]
  exact Classical.choose_spec h

end GateauxDeriv


namespace InnerProductOfMatrix
private theorem eq_of_pointwise_inner_product_and_trace_inner_product:
  Рѕђ {n m : Nat} (a b : Matrix (Fin n) (Fin m) РёЮ),
      innerProductofMatrix a b = traceMHDotM n m a b := by
    intro n m a b
    rw [innerProductofMatrix, traceMHDotM]
    rw [Рєљ mulрхБ_eq, mulрхБ]
    rw [trace]
    simp [dotProduct]
    exact Finset.sum_comm

-- (aр┤┤ b)рхбрхб = РѕЉ j, (aрхбР▒╝) * (bрхбР▒╝)
private theorem MHDotM (n m : Nat) (a b : Matrix (Fin n) (Fin m) РёЮ) :
  ((Рѕђ i : Fin m,
    (aр┤┤ * b).diag i =
    РѕЉ j : Fin n, (a j i) * (b j i))) := by
    intro id
    rw [Matrix.diag]
    rw [Рєљ mulрхБ_eq, mulрхБ]
    simp [dotProduct]


-- [aр┤┤ * a]рхбрхб РЅЦ 0
theorem diagPosMHDotM (n m : Nat) (a : Matrix (Fin n) (Fin m) РёЮ) :
  Рѕђ i, 0 РЅц (aр┤┤ * a).diag i := by
    intro x
    rw [MHDotM]
    apply Finset.sum_nonneg
    intro _ _
    rw [Рєљ pow_two]
    apply pow_two_nonneg


private theorem nonneg_of_inner_product_of_self_is_zero:
  Рѕђ {n m : Nat} (a : Matrix (Fin n) (Fin m) РёЮ),
      0 РЅц innerProductofMatrix a a := by
    intro n m a
    rw [eq_of_pointwise_inner_product_and_trace_inner_product]
    simp [traceMHDotM]
    rw [trace]
    apply Finset.sum_nonneg
    intro _ _
    apply diagPosMHDotM

theorem inner_product_of_self_is_zero_infer_zero_matrix:
  Рѕђ {n m : Nat} (a : Matrix (Fin n) (Fin m) РёЮ),
      innerProductofMatrix a a = 0 Рєњ a = 0 := by
  sorry

@[default_instance]
instance inner_product_space_of_matrix (n m : РёЋ): InnerProductSpace.Core РёЮ (Matrix (Fin n) (Fin m) РёЮ) :=
  {
    inner := innerProductofMatrix,
    conj_symm := by
      intro x y
      simp [innerProductofMatrix]
      have : Рѕђ i j, (x i j) * (y i j) = (y i j) * (x i j) := by
        intros
        apply mul_comm
      simp [this]
    nonneg_re := nonneg_of_inner_product_of_self_is_zero,
    definite := inner_product_of_self_is_zero_infer_zero_matrix,
    add_left := by
      intro x y z
      simp []
      repeat rw [eq_of_pointwise_inner_product_and_trace_inner_product]
      simp [traceMHDotM]
      rw [Matrix.add_mul]
      rw [Matrix.trace_add]
    smul_left := by
      intro x y a
      simp
      repeat rw [eq_of_pointwise_inner_product_and_trace_inner_product]
      simp [traceMHDotM]
  }

@[default_instance]

noncomputable
instance norm_of_matric (n m : РёЋ): NormedAddCommGroup (Matrix (Fin n) (Fin m) РёЮ) := InnerProductSpace.Core.toNormedAddCommGroup

@[default_instance]
noncomputable
instance inner_product (n m : РёЋ): InnerProductSpace РёЮ (Matrix (Fin n) (Fin m) РёЮ) := InnerProductSpace.ofCore (inner_product_space_of_matrix n m)

theorem trace_form_of_inner_product {n m : РёЋ} (a b : Matrix (Fin n) (Fin m) РёЮ) :
  trace (aрхђ * b) = РЪфa, bРЪФ_РёЮ := by
  have : inner a b = innerProductofMatrix a b := by
    rfl
  rw [this]
  simp [eq_of_pointwise_inner_product_and_trace_inner_product]
  rfl

end InnerProductOfMatrix


@[simp]
def f_aXb  {m n : Nat}(a : Fin m Рєњ РёЮ) (b : Fin n Рєњ РёЮ): Matrix (Fin m) (Fin n) РёЮ Рєњ РёЮ :=
  fun X => dotProduct a (mulVec X b)

lemma f_aXb_eq {m n : Nat}(a : Fin m Рєњ РёЮ) (b : Fin n Рєњ РёЮ) (X : Matrix (Fin m) (Fin n) РёЮ) :
  f_aXb a b X = innerProductofMatrix (vecMulVec a b) X := by
    simp [f_aXb, innerProductofMatrix, dotProduct, vecMulVec]
    dsimp [mulVec, dotProduct]
    apply Finset.sum_congr rfl
    intro i _
    rw [mul_sum]
    apply Finset.sum_congr rfl
    intro j _
    ring

-- define of upper triangle matrix
def is_upper_triangle {n : Nat} (A : Matrix (Fin n) (Fin n) РёЮ) : Prop :=
  Matrix.BlockTriangular A id

theorem is_upper_triangle.smul {n : Nat} {A : Matrix (Fin n) (Fin n) РёЮ} {c : РёЮ}
  (hA : is_upper_triangle A) : is_upper_triangle (c Рђб A) := by
    simp [is_upper_triangle, BlockTriangular] at *
    intro _ _ hij
    exact Or.inr (hA hij)

theorem is_upper_triangle.add {n : Nat} {A B : Matrix (Fin n) (Fin n) РёЮ}
    (hA : is_upper_triangle A) (hB : is_upper_triangle B): is_upper_triangle (A + B) := by
  simp [is_upper_triangle] at *   -- *СИ║т░єТЅђТюЅуџёТаЄУ«░жЃйтїќу«ђ
  exact Matrix.BlockTriangular.add hA hB

theorem is_upper_triangle.one {n : Nat} : is_upper_triangle (1 : Matrix (Fin n) (Fin n) РёЮ) := by
  simp [is_upper_triangle]
  exact Matrix.blockTriangular_one

theorem upper_triangle_det {n : Nat} {A : Matrix (Fin n) (Fin n) РёЮ} (h : is_upper_triangle A) :
  det A = РѕЈ i : Fin n, A i i := by
  simp [is_upper_triangle] at h
  exact (Matrix.det_of_upperTriangular h)

-- Matrix.det_of_upperTriangular

-- define of orthogonal matrix
def Orthogonal_Matrix {n : Nat} (A : Matrix (Fin n) (Fin n) РёЮ ) : Prop :=
  Aрхђ * A = 1

theorem det_notzero {n : Nat} (A : Matrix (Fin n) (Fin n) РёЮ): -- УдЂтљѕжђѓуџётЈќ ╬┤ ТЮЦУ»ЂТўј
  РѕЃ ╬┤ > 0, Рѕђ x : РёЮ, |x| < ╬┤ Рєњ det (1 + x Рђб A) РЅа 0 := by
  sorry

theorem ln_delta_epsilon (R: Real): -- УдЂтљѕжђѓуџётЈќ ╬┤ ТЮЦУ»ЂТўј
  Рѕђ ╬х > 0, РѕЃ ╬┤ > 0, Рѕђ x РЅа 0, |x| < ╬┤ Рєњ |Real.log (1 + x * R) / x - R| < ╬х := by
  have hR := Real.tendsto_mul_log_one_plus_div_atTop R
  have hnR := Real.tendsto_mul_log_one_plus_div_atTop (-R)
  rw [Metric.tendsto_atTop] at hR
  rw [Metric.tendsto_atTop] at hnR
  simp [dist] at *
  intro ╬х' h╬х'
  specialize hR ╬х' h╬х'
  specialize hnR ╬х' h╬х'
  let РЪеN1, hN1РЪЕ  := hR
  let РЪеN2, hN2РЪЕ  := hnR
  let ╬┤ := 1 / max 1 (1 + max N1 N2)
  have h╬┤ : N1 < 1/╬┤ РѕД N2 < 1/╬┤ := by
    constructor
    ┬и simp; right;
      linarith [zero_lt_one', le_max_left N1 N2]
    ┬и simp; right;
      linarith [zero_lt_one', le_max_right N1 N2]
  use ╬┤
  have hpos_╬┤ : 0 < ╬┤ := div_pos
    (by norm_num)
    (lt_of_lt_of_le (by norm_num) (le_max_left 1 (1 + max N1 N2)))
  constructor
  ┬и exact hpos_╬┤
  intro x hnx hx
  rcases (Ne.lt_or_lt hnx) with (hxl | hxr)
  ┬и let y := - 1 / x
    have hxy : x = - 1 / y := by simp [y, Рєљ div_mul]
    rw [hxy, div_mul_eq_mul_div, neg_one_mul, Рєљ div_mul, div_neg, div_one]
    rw [neg_mul, neg_sub_left, abs_neg, add_comm, mul_comm]
    rw [abs_of_neg hxl] at hx
    have hy : N2 РЅц y := by
      have hpos_y: 0 < y := by apply one_div_pos.mp; simp; linarith;
      rw [hxy, neg_div, neg_neg] at hx
      apply (one_div_lt hpos_y hpos_╬┤).mp at hx
      linarith [hx, h╬┤.2]
    exact hN2 y hy
  ┬и let y := 1 / x
    have hxy : x = 1 / y := by simp [y]
    rw [mul_comm x R]
    rw [hxy, mul_one_div, Рєљ div_mul, div_one, mul_comm]
    rw [abs_of_pos hxr] at hx
    have hy : N1 РЅц y := by
      have hpos_y: 0 < y := by apply one_div_pos.mp; linarith [hxy, hxr]
      rw [hxy] at hx
      apply (one_div_lt hpos_y hpos_╬┤).mp at hx
      linarith [hx, h╬┤.1]
    exact hN1 y hy

theorem upper_nonezero {n: Nat} (A : Matrix (Fin n) (Fin n) РёЮ): -- т«џуљєтљЇуД░тљјуџёуЏИтйЊС║јТў»С╗╗ТёЈуџёТЮАС╗Х (Рѕђ n: Nat,...)
  is_upper_triangle A Рєњ det (A) РЅа 0 Рєњ Рѕђ i : Fin n, A i i РЅа 0 := by
  intro i hi
  rw [upper_triangle_det] at hi -- тѕЕућеТІгтЈитєЁуџёТЮАС╗ХТЮЦrewrite hi
  simp [Finset.prod_ne_zero_iff.mp hi]
  assumption

-- schur decomposition theorem
theorem schur_decomposition (n: Nat) (A : Matrix (Fin n) (Fin n) РёЮ) :
    РѕЃ U R, Orthogonal_Matrix U РѕД is_upper_triangle R РѕД A = Uрхђ * R * U := by
  sorry

theorem Orthogonal_inv {n : Nat} (A : Matrix (Fin n) (Fin n) РёЮ):
  Orthogonal_Matrix A Рєњ A * Aрхђ= 1 := by
  intro h
  simp [Orthogonal_Matrix] at h
  have this: AРЂ╗┬╣ = Aрхђ:= by
    exact inv_eq_left_inv h
  rw [Рєљ this]
  have hh : РѕЃ B, B * A = 1 := by
    use Aрхђ
  have hhh := Matrix.vecMul_surjective_iff_exists_left_inverse.mpr hh
  have hhhh := Matrix.vecMul_surjective_iff_isUnit.mp hhh
  have hhhhh : Invertible A := by
    exact Matrix.invertibleOfIsUnitDet A ((Matrix.isUnit_iff_isUnit_det A).mp hhhh)
  simp [Matrix.mul_inv_of_invertible A] -- simpleУЙЊтЁЦТІгтЈитєЁуџётЈѓТЋ░ Тќ╣ТАєтєЁуџёassumptionС╝џУЄфУАїт»╗ТЅЙ
-- Matrix.mulVec_surjective_iff_exists_right_inverse
